=head1 NAME

Catalyst::Manual::Intro - Introduction to Catalyst

=head1 DESCRIPTION

This is a brief overview of why and how to use Catalyst. It explains how Catalyst works and shows how to get a simple application up and running quickly.

=head2 What is Catalyst?

Catalyst is an elegant web application framework, extremely flexible yet extremely simple. It's similar to Ruby on Rails, Spring (Java) and L<Maypole>, upon which it was originally based.

=head3 MVC

Catalyst follows the Model-View-Controller (MVC) design pattern, allowing you to easily separate concerns, like content, presentation, and flow control, into separate modules. This separation allows you to modify code that handles one concern without affecting code that handles the others. Catalyst promotes the re-use of existing Perl modules that already handle common web application concerns well.

Here's how the M, V, and C map to those concerns, with examples of well-known Perl modules you may want to use for each.

=over 4

=item * B<Model>

Access and modify content (data). L<Class::DBI>, L<Plucene>, L<Net::LDAP>...

=item * B<View>

Present content to the user. L<Template Toolkit|Template>, L<Mason|HTML::Mason>...

=item * B<Controller>

Control the whole request phase, check parameters, dispatch actions, flow control. Catalyst!

=back

If you're unfamiliar with MVC and design patterns, you may want to check out the original book on the subject, I<Design Patterns>, by Gamma, Helm, Johson and Vlissides, also known as the Gang of Four (GoF). You can also just google it. Many, many web application frameworks are based on MVC, including all those listed above.

=head3 Flexibility

Catalyst is much more flexible than many other frameworks. We'll talk more about this later, but rest assured you can use your favorite Perl modules with Catalyst.

=over 4

=item * B<Multiple Models, Views, and Controllers>

To build a Catalyst application, you handle each type of concern inside special modules called L</Components>. Often this code will be very simple, just calling out to Perl modules like those listed above under L</MVC>. Catalyst handles these components in a very flexible way. Use as many Models, Views, and Controllers as you like, using as many different Perl modules as you like, all in the same application. Want to manipulate multiple databases, and retrieve some data via LDAP? No problem. Want to present data from the same Model using L<Template Toolkit|Template> and L<PDF::Template>? Easy.

=item * B<Reuseable Components>

Not only does Catalyst promote the re-use of already existing Perl modules, it also allows you to re-use your Catalyst components in multiple Catalyst applications. 

=item * B<Unrestrained URL-to-Action Dispatching>

Catalyst allows you to dispatch any URLs to any application L<Actions>, even through regular expressions! Unlike most other frameworks, it doesn't require mod_rewrite or class and method names in URLs.

With Catalyst you register your actions and address them directly. For example:

    sub hello : Global {
        my ( $self, $context ) = @_;
        $context->response->output('Hello World!');
    }

Now http://localhost:3000/hello prints "Hello World!".

=item * B<Support for CGI, mod_perl, Apache::Request>

Use L<Catalyst::Engine::Apache> or L<Catalyst::Engine::CGI>.

=back

=head3 Simplicity

The best part is that Catalyst implements all this flexibility in a very simple way.

=over 4

=item * B<Building Block Interface>

Components interoperate very smoothly. For example, Catalyst automatically makes a L<Context> object available to every component. Via the context, you can access the request object, share data between components, and control the flow of your application. Building a Catalyst application feels a lot like snapping together toy building blocks, and everything just works.

=item * B<Component Auto-Discovery>

No need to C<use> all of your components. Catalyst automatically finds and loads them.

=item * B<Pre-Built Components for Popular Modules>

See L<Catalyst::Model::CDBI> for L<Class::DBI>, or L<Catalyst::View::TT> for L<Template Toolkit|Template>. You can even get an instant web database front end with L<Catalyst::Model::CDBI::CRUD>.

=item * B<Built-in Test Framework>

Catalyst comes with a built-in, lightweight http server and test framework, making it easy to test applications from the command line.

=item * B<Helper Scripts>

Catalyst provides helper scripts to quickly generate running starter code for components and unit tests.

=back

=head2 Quickstart

Here's how to install Catalyst and get a simple application up and running, using the helper scripts described above.

=head3 Install

    $ perl -MCPAN -e 'install Bundle::Catalyst'

=head3 Setup

    $ catalyst.pl MyApp
    $ cd MyApp
    $ script/create.pl controller My::Controller

=head3 Run

    $ script/server.pl

Now visit these locations with your favorite browser or user agent to see Catalyst in action:

=over 4

=item http://localhost:3000/

=item http://localhost:3000/my/controller/

=back

Dead easy!

=head2 How It Works

Let's see how Catalyst works, by taking a closer look at the components and other parts of a Catalyst application.

=head3 Application Class

In addition to the Model, View, and Controller components, there's a single class that represents your application itself. This is where you configure your application, load plugins, define application-wide actions and extend Catalyst.

    package MyApp;

    use strict;
    use Catalyst qw/-Debug/;

    MyApp->config(
        name => 'My Application',
        root => '/home/joeuser/myapp/root',

        # You can put whatever you want in here:
        # my_param_name => $my_param_value,
    );

    sub default : Private {
        my ( $self, $context ) = @_;
        $context->response->output('Catalyst rockz!');
    }

    1;

For most applications, Catalyst requires you to define only two config parameters:

=over 4

=item * B<name>

Name of your application.

=item * B<root>

Path to additional files such as templates, images, or other static data.

=back

However, you can define as many parameters as you want for plugins or whatever you need. You can access them anywhere in your application via C<$context-E<gt>config-E<gt>{$param_name}>.

=head3 Context

Catalyst automatically blesses a Context object into your application class and makes it available everywhere in your application. Use the Context to directly interact with Catalyst and glue your L<Components> together. 

As illustrated earlier in our URL-to-Action dispatching example, the Context is always the second method parameter, behind the Component object reference or class name itself. Previously we called it C<$context> for clarity, but most Catalyst developers just call it C<$c>:

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->res->output('Hello World!');
    }

The Context contains several important objects:

=over 4

=item * L<Catalyst::Request>

    $c->request
    $c->req # alias

The request object contains all kinds of request-specific information, like query parameters, cookies, uploads, headers, and more.

    $c->req->params->{foo};
    $c->req->cookies->{sessionid};
    $c->req->headers->content_type;
    $c->req->base;

=item * L<Catalyst::Response>

    $c->response
    $c->res # alias

The response is like the request, but contains just response-specific information.

    $c->res->output('Hello World');
    $c->res->status(404);
    $c->res->redirect('http://oook.de');

=item * L<Catalyst::Config>

    $c->config

    $c->config->root;
    $c->config->name;

=item * L<Catalyst::Log>

    $c->log

    $c->log->debug('Something happened');
    $c->log->info('Something you should know');

=item * B<Stash>

    $c->stash

    $c->stash->{foo} = 'bar';

=back

The last of these, the stash, is a universal hash for sharing data among application components. For an example, we return to our 'hello' action:

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $c->forward('show_message');
    }

    sub show_message : Private {
        my ( $self, $c ) = @_;
        $c->res->output( $c->stash->{message} );
    }

=head3 Actions

A Catalyst controller is defined by its actions. An action is
a sub with a special attribute. You've already seen some
examples of actions in this document.

Catalyst supports several types of actions:

=over 4

=item * B<Literal>

    sub bar : Path('/foo/bar') { }

Matches only http://localhost:3000/foo/bar.

=item * B<Regex>

    sub bar : Regex('^foo(\d+)/bar(\d+)$') { }

Matches any URL that matches the pattern in the action key, e.g. http://localhost:3000/foo23/bar42. The '' around the regexp is optional, but perltidy likes it. :)

If you use capturing parentheses to extract values within the matching URL (23, 42 in the above example), those values are available in the $c->req->snippets array. If you want to pass arguments at the end of your URL, you must use regex action keys. See L</URL Argument Handling> below.

=item * B<Top-level>

    package MyApp; 
    sub foo : Global { }

Matches http://localhost:3000/foo. The function name is mapped 
directly to the application base.

=item * B<Namespace-Prefixed>

    package MyApp::C::My::Controller; 
    sub foo : Local { }

Matches http://localhost:3000/my/controller/foo. 

This action type indicates that the matching URL must be prefixed with a modified form of the component's class (package) name. This modified class name excludes the parts that have a pre-defined meaning in Catalyst ("MyApp::C" in the above example), replaces "::" with "/", and converts the name to lower case. See L</Components> for a full explanation of the pre-defined meaning of Catalyst component class names.

=item * B<Private>

    sub foo : Private { }

Matches no URL, and cannot be executed by requesting a URL that corresponds to the action key. Private actions can be executed only inside a Catalyst application, by calling the C<forward> method:

    $c->forward('foo');

See L</Flow Control> for a full explanation of C<forward>.

=back

B<Note:> After seeing these examples, you probably wonder what the point is of defining names for regex and path actions. Actually, every public
action is also a private one, so you have one unified way of addressing components in your C<forward>s.

=head4 Built-in Private Actions

In response to specific application states, Catalyst will automatically call these built-in private actions:

=over 4

=item * B<default : Private>

Called when no other action matches.

=item * B<begin : Private>

Called at the beginning of a request, before any matching actions are called.

=item * B<end : Private>

=back

Called at the end of a request, after all matching actions are called.

=head4 B<Built-in actions in controllers/autochaining>

    Package MyApp::C::Foo;
    sub begin : Private { }
    sub default : Private { }

You can define the Built-in Private Actions within your controllers as 
well. The actions will override the ones in lower level controllers/
global.

In addition to the normal built-ins, you have a special action for 
making inheritance chains, 'auto'. These will be run after C<begin>, 
but before your action is processed.

=over 4

=item for a request for /foo/foo

  MyApp::begin
  MyApp::auto
  MyApp::C::Foo::default
  MyApp::end

=item for a request for /foo/bar/foo

  MyApp::C::Foo::Bar::begin
  MyApp::auto
  MyApp::C::Foo::auto
  MyApp::C::Foo::Bar::default
  MyApp::C::Foo::Bar::end

=back

Also, if you need to break out of the chain in one of your auto 
actions, you can return 0, if so, your action will not be processed,
but the end will, so for the request above, if the first auto returns
false, it would look like this:

=over 4

=item for a request for /foo/bar/foo where auto returns false

  MyApp::C::Foo::Bar::begin
  MyApp::auto
  MyApp::C::Foo::Bar::end

=back

B<Note:> auto actions have to return a true value to continue processing!
You can also die in the autochain action, in that case,
the request will go straight to the finalize stage, without processing
further actions.


=head4 B<URL Argument Handling>

If you want to pass variable arguments at the end of a URL, you must use regex actions keys with '^' and '$' anchors, and the arguments must be separated with forward slashes (/) in the URL. For example, suppose you want to handle /foo/$bar/$baz, where $bar and $baz may vary:

    sub foo : Regex('^foo$') { my ($self, $context, $bar, $baz) = @_; }

But what if you also defined actions for /foo/boo and /foo/boo/hoo ?

    sub boo : Path('/foo/boo') { .. }
    sub hoo : Path('/foo/boo/hoo') { .. }

Catalyst matches actions in most specific to least specific order:

    /foo/boo/hoo
    /foo/boo
    /foo # might be /foo/bar/baz

So Catalyst would never mistakenly dispatch the first two URLs to the '^foo$' action.

=head3 Flow Control

You control the application flow with the C<forward> method, which accepts the key of an action to execute.

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{message} = 'Hello World!';
        $c->forward('check_message');
    }

    sub check_message : Private {
        my ( $self, $c ) = @_;
        return unless $c->stash->{message};
        $c->forward('show_message');
    }

    sub show_message : Private {
        my ( $self, $c ) = @_;
        $c->res->output( $c->stash->{message} );
    }
    
As you can see from these examples, you can just use the method name as long as you are referring to methods in the same controller. If you want to forward to a method in another controller, or the main application, you will have to refer to the method by absolute path.

  $c->forward('/my/controller/action');
  $c->forward('/default');

You can also forward to classes and methods.

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->forward(qw/MyApp::M::Hello say_hello/);
    }

    sub bye : Global {
        my ( $self, $c ) = @_;
        $c->forward('MyApp::M::Hello');
    }

    package MyApp::M::Hello;

    sub say_hello {
        my ( $self, $c ) = @_;
        $c->res->output('Hello World!');
    }

    sub process {
        my ( $self, $c ) = @_;
        $c->res->output('Goodbye World!');
    }

Note that C<forward> returns to the calling action and continues processing after the action finishes.
Catalyst will automatically try to call process() if you omit the method.

=head3 Components

Catalyst has an uncommonly flexible component system. You can define as many L<Models>, L<Views>, and L<Controllers> as you like.

All components must inherit from L<Catalyst::Base>, which provides a simple class structure and some common class methods like C<config> and C<new> (constructor).

    package MyApp::C::MyController;

    use strict;
    use base 'Catalyst::Base';

    __PACKAGE__->config( foo => 'bar' );

    1;

You don't have to C<use> or otherwise register Models, Views, and Controllers. Catalyst automatically discovers and instantiates them when you call C<setup> in the main application. All you need to do is put them in directories named for each Component type. Notice that you can use some very terse aliases for each one.

=over 4

=item * B<MyApp/Model/> 

=item * B<MyApp/M/>

=item * B<MyApp/View/>

=item * B<MyApp/V/>

=item * B<MyApp/Controller/>

=item * B<MyApp/C/>

=back

=head4 Views

To show how to define views, we'll use an already-existing base class for the L<Template Toolkit|Template>, L<Catalyst::View::TT>. All we need to do is inherit from this class:

    package MyApp::V::TT;

    use strict;
    use base 'Catalyst::View::TT';

    1;

This gives us a process() method and we can now just do $c->forward('MyApp::V::TT') to render our templates. The base class makes process() implicit, so we don't have to say C<$c-E<gt>forward(qw/MyApp::V::TT process/)>.

    sub hello : Global {
        my ( $self, $c ) = @_;
        $c->stash->{template} = 'hello.tt';
    }

    sub end : Private {
        my ( $self, $c ) = @_;
        $c->forward('MyApp::V::TT');
    }

You normally render templates at the end of a request, so it's a perfect use for the global C<end> action.

Also, be sure to put the template under the directory specified in C<$c-E<gt>config-E<lt>{root}>, or you'll be forced to look at our eyecandy debug screen. ;)

=head4 Models

To show how to define models, again we'll use an already-existing base class, this time for L<Class::DBI>: L<Catalyst::Model::CDBI>.

But first, we need a database.

    -- myapp.sql
    CREATE TABLE foo (
        id INTEGER PRIMARY KEY,
        data TEXT
    );

    CREATE TABLE bar (
        id INTEGER PRIMARY KEY,
        foo INTEGER REFERENCES foo,
        data TEXT
    );

    INSERT INTO foo (data) VALUES ('TEST!');


    % sqlite /tmp/myapp.db < myapp.sql

Now we can create a CDBI component for this database.

    package MyApp::M::CDBI;

    use strict;
    use base 'Catalyst::Model::CDBI';

    __PACKAGE__->config(
        dsn           => 'dbi:SQLite:/tmp/myapp.db',
        relationships => 1
    );

    1;

Catalyst automatically loads table layouts and relationships. Use the stash to pass data to your templates.

    package MyApp;

    use strict;
    use Catalyst '-Debug';

    __PACKAGE__->config(
        name => 'My Application',
        root => '/home/joeuser/myapp/root'
    );
    
    __PACKAGE__->setup;

    sub end : Private {
        my ( $self, $c ) = @_;
        $c->stash->{template} ||= 'index.tt';
        $c->forward('MyApp::V::TT');
    }

    sub view : Global {
        my ( $self, $c, $id ) = @_;
        $c->stash->{item} = MyApp::M::CDBI::Foo->retrieve($id);
    }

    1;

    The id is [% item.data %]

=head4 Controllers

Multiple controllers are a good way to separate logical domains of your application.

    package MyApp::C::Login;

    sign-in : Local { }
    new-password : Local { }
    sign-out : Local { }

    package MyApp::C::Catalog;

    sub view : Local { }
    sub list : Local { }

    package MyApp::C::Cart;

    sub add : Local { }
    sub update : Local { }
    sub order : Local { }

=head3 Testing

Catalyst has a built-in http server for testing! (Later, you can easily use a more powerful server, e.g. Apache/mod_perl, in a production environment.)

Start your application on the command line...

    script/server.pl

...then visit http://localhost:3000/ in a browser to view the output.

You can also do it all from the command line:

    script/test.pl http://localhost/

Have fun!

=head1 SUPPORT

IRC:

    Join #catalyst on irc.perl.org.

Mailing-lists:

    http://lists.rawmode.org/mailman/listinfo/catalyst
    http://lists.rawmode.org/mailman/listinfo/catalyst-dev

=head1 AUTHOR

Sebastian Riedel, C<sri@oook.de> 
David Naughton, C<naughton@umn.edu>
Marcus Ramberg, C<mramberg@cpan.org>
Jesse Sheidlower, C<jester@panix.com>

=head1 COPYRIGHT

This program is free software, you can redistribute it and/or modify it under
the same terms as Perl itself.
